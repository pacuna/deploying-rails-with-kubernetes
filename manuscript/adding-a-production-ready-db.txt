### Adding a production-ready database

In this section we'll add a real database to our application. Typically
you would use MySQL or Postgres or a NoSQL database like
MongoDB in production. The setup for any of these would be pretty similar if you're using containers. 
You just need the correct configuration in order to run the images.
In this case we'll go with Postgres.

We are going to be using the [official Postgres image](https://hub.docker.com/_/postgres/)
from DockerHub. The environment variables that this image uses for running are
`POSTGRES_PASSWORD`, `POSTGRES_USER`, and `POSTGRES_DB`. You can find a full list
in the documentation, but for us these will be enough for now:

First, let's add a Postgres section in our docker-compose.yml file:

    postgres:
      image: postgres:9.4
      container_name: myapp-db
      environment:
        - POSTGRES_USER=myapp
        - POSTGRES_DB=myapp_development
        - POSTGRES_PASSWORD=secretpassword

If you want to persist your data in your development environment, you'll need
to mount a data-only container for this database. You can achieve this by adding
another section for that container:

    postgres-data:
      image: postgres:9.4
      container_name: myapp-data
      environment:
        - POSTGRES_PASSWORD=secretpassword
      volumes:
        - /var/lib/postgresql/data
      command: /bin/true

And then mount the correct path on the database container:

    postgres:
      image: postgres:9.4
      container_name: myapp-db
      environment:
        - POSTGRES_USER=myapp
        - POSTGRES_DB=myapp_development
        - POSTGRES_PASSWORD=secretpassword
      volumes_from:
        - postgres-data

Now we can use the new Docker networking feature in order to connect
our database container with our application container. For that we have to
use the version 2 of docker-compose, so at the beginning of the docker-compose.yml
file add:

    version: '2'

And now let's move the app and the db to a services section with the same
network:

    version: '2'
    services:
      webapp:
        build: .
        container_name: myapp
        working_dir: /home/app/webapp
        ports: 
          - "80:80"
        environment:
          - PASSENGER_APP_ENV=development
        volumes:
          - .:/home/app/webapp
        networks: 
          - back-end
      postgres:
        image: postgres:9.4
        container_name: myapp-db
        environment:
          - POSTGRES_USER=myapp
          - POSTGRES_DB=myapp_development
          - POSTGRES_PASSWORD=secretpassword
        volumes_from:
          - postgres-data
        networks:
          - back-end
      postgres-data:
        image: postgres:9.4
        container_name: myapp-data
        environment:
          - POSTGRES_PASSWORD=secretpassword
        volumes:
          - /var/lib/postgresql/data
        command: /bin/true
    networks:
      back-end:
        driver: bridge

Now we can connect to the database from our web application by using
the service alias `postgres` instead of using the old linking via environmental variables.

Now that we're ready with the Docker Compose yaml file, let's add the Postgres gem
to our application. Remember that you can modify the code locally
since we are mounting a volume from the local project to the project inside of the
container. Add the following to your Gemfile:

    gem 'pg', '~> 0.18'

And now from inside the container run bundle install:

    $ docker exec -it myapp bash
    # bundle install

And then add the following to your `config/database.yml` file:

    default: &default
      adapter: postgresql
      encoding: unicode
      pool: 5

    development:
      <<: *default
      database: myapp_development
      username: myapp
      password: secretpassword
      host: postgres
      port: 5432

    test:
      <<: *default
      database: myapp_test

    production:
      <<: *default
      database: myapp_production
      username: myapp
      password: secretpassword

Now let's rebuild our application:

    $ docker-compose stop
    $ docker-compose build

And run up:

    $ docker-compose up

This will pull the postgres image, run the container and create
the user and database we specified before.

Now we just need to run the migrations for our scaffold:

    $ docker exec -it myapp bash
    # rake db:migrate

And that's it!, now you can visit your application connected to the postgres
database and test that that everything works as expected.
