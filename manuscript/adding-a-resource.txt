### Adding a resource

Now that we have our application up and running, let's scaffold a resource
so later we can test more than just the Rails welcome page.
The application is running inside of the phusion passenger container, and
we have two options for interacting with the application. The first option
is to run commands by using docker-compose as a wrapper. For example
we could run:

    $ docker-compose run webapp rails c

And that would take us to the `webapp` service defined in our docker-compose
which corresponds to the myapp application, and open a rails console
inside of it.

The second option would be to create a bash session inside of the container
and run the commands directly there. For example:

    $ docker exec -it myapp bash
    # rails c

The first command takes you to the container and from there you can run
any rails or rake commands you want. 
I prefer to use the second approach simply because using docker-compose for running
commands will create containers for running everyone of these commands, and those containers will
stay there using disk space. You can see this by running some commands using `docker-compose run`
and then listing all of the containers:

    $ docker ps -a

Output:

    CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS                          PORTS                         NAMES
    d2aa78889f2a        myapp_webapp            "rails c"                11 seconds ago      Exited (0) 3 seconds ago                                      myapp_webapp_run_2
    bda9ef328673        myapp_webapp            "rails c"                2 minutes ago       Exited (0) About a minute ago                                 myapp_webapp_run_1
    85f1508c8705        myapp_webapp            "/sbin/my_init"          2 hours ago         Up 7 minutes                    0.0.0.0:80->80/tcp, 443/tcp   myapp

You see that we have our application running with the name `myapp`, but we also
have two containers that were created just for running the rails commands. Of course
the status of those containers is exited since they were created just for that.

When you use `docker exec` instead, you are just going inside of the running
container and not creating an extra one. So let's just stick with that approach.

Let's go inside of the container and create a very simple scaffold:

    $ docker exec -it myapp bash
    # rails g scaffold article title:string body:text
    # rake db:migrate

Now you can visit the path '/articles' and you should be able to list and
add articles.

If you want to run the tests created during the scaffold, you can run:

    # rake

Output:

    Run options: --seed 40448

    # Running:

    .......

    Finished in 3.119099s, 2.2442 runs/s, 3.8473 assertions/s.

    7 runs, 12 assertions, 0 failures, 0 errors, 0 skips

We will use these tests later in our Continuous Integration chapter.
