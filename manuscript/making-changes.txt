### Making changes to the application

Right now we have our application live running with Kubernetes. That's cool. But
now we want to make some changes and send those changes to production.
In the next chapter we'll create an appropriate Continuous Integration environment
for manage this requirement. But for now, let me show you another Kubernetes element
that you need to understand: the `rolling-update` command.
Basically, this command will allow you to deploy changes to one of your pods, in our
case the Rails application. This rolling-update concepts differs with the typical
deploys you may have seen in the sense that there's going to be a moment in which
you'll have both the old and the new version running together, and just then, when
the new version it's stable and up, the old version will be discarded and the containers
terminated.
Let's make an small change to our application and the run a rolling-update for
our app.

We are going to add another scaffold, this time for managing authors.
Go to your application container and run:

    # rails g scaffold author name:string username:string email:string bio:text
    # rake db:migrate

Let's deploy this change by using a kubernetes rolling-update. 
For this command we need the version we want to replace, and the template with
the new version to deploy.

If you're not sure of what version is up, you can run:

    $ kubectl get replicationcontrollers --namespace production

Output:

    NAME       DESIRED   CURRENT   AGE
    myapp-v2   1         1         1d

So in my case I'm running version 2. Open the deploy/kube/rcs/myapp-production.yaml
file and replace that version with a new one:

    apiVersion: v1
    kind: ReplicationController
    metadata:
      name: myapp-v3
    spec:
      replicas: 1
      selector:
        app: myapp
        deployment: v3
      template:
        metadata:
          name: myapp
          labels:
            app: myapp
            deployment: v3
        spec:
          containers:
          - name: myapp
            image: pacuna/myapp:3
            ports:
              - containerPort: 80
            env:
              - name: PASSENGER_APP_ENV
                value: production

Now rebuild the image and push it to DockerHub. We have to tag our image with
the number 3 to match the value we put in the image spec of the template:

    $ docker build -t username/myapp:3 .
    $ docker push username/myapp:3

Now we can the run the command:

    $ kubectl rolling-update myapp-v2 -f deploy/kube/rcs/myapp-production.yaml --namespace production


For moment you'll see this output:


Output:

    Created myapp-v3
    Scaling up myapp-v3 from 0 to 1, scaling down myapp-v2 from 1 to 0 (keep 1 pods available, don't exceed 2 pods)
    Scaling myapp-v3 up to 1
    Scaling myapp-v2 down to 0

That's when kubernetes is launching the new version, waiting for it to be stable
and then dropping the old one.
When the process is finished, you'll see:

    Created myapp-v3
    Scaling up myapp-v3 from 0 to 1, scaling down myapp-v2 from 1 to 0 (keep 1 pods available, don't exceed 2 pods)
    Scaling myapp-v3 up to 1
    Scaling myapp-v2 down to 0
    Update succeeded. Deleting myapp-v2
    replicationcontroller "myapp-v2" rolling updated to "myapp-v3"

Let's run the command to describe our service again:

    $ kubectl describe service myapp --namespace production

Output:

    Name:			myapp-service
    Namespace:		production
    Labels:			<none>
    Selector:		app=myapp
    Type:			LoadBalancer
    IP:			10.0.160.160
    LoadBalancer Ingress:	adff1155b171211e6a279065abcbcf5b-1127508601.us-west-2.elb.amazonaws.com
    Port:			<unset>	80/TCP
    NodePort:		<unset>	30345/TCP
    Endpoints:		10.244.3.4:80
    Session Affinity:	None
    No events.

As you can see, my endpoint hasn't changed. Go to your endpoint, to the
`/authors` path and you should see our new scaffold in action.
